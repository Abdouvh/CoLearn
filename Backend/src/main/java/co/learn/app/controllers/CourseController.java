package co.learn.app.controllers;

import co.learn.app.entities.Course;
import co.learn.app.entities.Module;
import co.learn.app.repositories.CourseRepository;
import co.learn.app.repositories.ModuleRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity; // Required
import org.springframework.transaction.annotation.Transactional; // Required
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/courses")
@CrossOrigin(origins = "*")
public class CourseController {

    @Autowired
    private CourseRepository courseRepository;

    @Autowired
    private ModuleRepository moduleRepository;

    @Autowired
    private co.learn.app.services.GeminiService geminiService;

    @Autowired
    private com.google.gson.Gson gson;

    @PostMapping("/generate")
    public Course generateCourse(@RequestBody Map<String, String> request) {
        String topic = request.get("topic");
        String lang = request.get("language"); // "fr" or "en"
        String level = request.get("level");

        // 1. Construct the Prompt (Updated with Escaping Instructions)
        String languageName = "fr".equalsIgnoreCase(lang) ? "French" : "English";
        String prompt = String.format(
                "Act as an expert tutor. Create a comprehensive course about '%s'.\n" +
                        "TARGET AUDIENCE: Level '%s'.\n" +
                        "LANGUAGE: The content MUST be in '%s'.\n" +
                        "OUTPUT FORMAT: Return STRICTLY valid JSON (no markdown, no ```json fences).\n" +
                        "IMPORTANT: If using backslashes in text (e.g. for LaTeX, paths, or code), you MUST double-escape them (e.g. use \\\\ instead of \\). Ensure all quotes are escaped properly.\n"
                        +
                        "Matches this structure:\n"
                        +
                        "{ \"title\": \"Course Title (in %s)\", \"description\": \"Engaging description (in %s)\", " +
                        "\"modules\": [ " +
                        "{ \"title\": \"Module 1 Title\", \"content\": \"Educational content matching level %s (min 200 words)...\" }, "
                        +
                        "{ \"title\": \"Module 2 Title\", \"content\": \"Detailed educational content (at least 200 words)...\" }, "
                        +
                        "{ \"title\": \"Module 3 Title\", \"content\": \"Deep dive...\" }, " +
                        "{ \"title\": \"Quiz\", \"content\": \"Question 1: ... ?\\nOptions: ...\\nCorrect Answer: ...\" } "
                        +
                        "] }",
                topic, level, languageName, languageName, languageName, level);

        System.out.println("Generating course with prompt: " + prompt);

        // 2. Call Gemini API
        String jsonResponse = geminiService.generateContent(prompt);

        // 3. Clean and Parse JSON
        jsonResponse = jsonResponse.replace("```json", "").replace("```", "").trim();

        try {
            return parseAndSaveCourse(jsonResponse, topic, level, lang);
        } catch (Exception e) {
            System.err.println("First parse attempt failed: " + e.getMessage());
            // Retry with aggressive sanitization
            String sanitizedJson = sanitizeJson(jsonResponse);
            try {
                return parseAndSaveCourse(sanitizedJson, topic, level, lang);
            } catch (Exception ex) {
                System.err.println("Second parse attempt failed: " + ex.getMessage());
                throw new RuntimeException("Failed to generate course. Please try again.");
            }
        }
    }

    private String sanitizeJson(String json) {
        // Replace single backslashes that are NOT followed by valid escape characters
        // with double backslashes
        // Valid JSON escapes: " \ / b f n r t u
        // This regex looks for \ followed by anything NOT in ["\\/bfnrtu]
        return json.replaceAll("\\\\(?![\\\\\"/bfnrtu])", "\\\\\\\\");
    }

    private Course parseAndSaveCourse(String jsonResponse, String topic, String level, String lang) {
        Map<String, Object> data = gson.fromJson(jsonResponse, Map.class);

        Course course = new Course();
        course.setTitle((String) data.getOrDefault("title", topic));
        course.setDescription((String) data.getOrDefault("description", "Generated by AI"));
        course.setLevel(level);
        course.setLanguage(lang);
        course.setIcon("school");

        List<Module> modules = new ArrayList<>();
        List<Map<String, String>> modulesData = (List<Map<String, String>>) data.get("modules");

        if (modulesData != null) {
            for (int i = 0; i < modulesData.size(); i++) {
                Map<String, String> mData = modulesData.get(i);
                Module module = new Module();
                module.setTitle(mData.get("title"));
                module.setContent(mData.get("content"));

                // Unlock FIRST module only
                module.setLocked(i != 0);

                modules.add(module);
            }
        }

        course.setModules(modules);
        return courseRepository.save(course);
    }

    @GetMapping
    public List<Course> getAllCourses() {
        return courseRepository.findAll();
    }

    // --- FIX: SAVING PROGRESS ---
    @PutMapping("/modules/{id}/unlock")
    @Transactional // <--- CRITICAL: Forces DB to save the change
    public ResponseEntity<?> unlockModule(@PathVariable Long id) {
        System.out.println(">>> SAVING: Unlocking Module ID " + id);

        return moduleRepository.findById(id).map(module -> {
            module.setLocked(false); // Unlock it
            moduleRepository.save(module); // Save it
            return ResponseEntity.ok().build();
        }).orElseGet(() -> {
            return ResponseEntity.notFound().build();
        });
    }

    @PutMapping("/{id}/complete")
    @Transactional
    public ResponseEntity<?> markCourseCompleted(@PathVariable Long id) {
        System.out.println(">>> SAVING: Completing Course ID " + id);
        return courseRepository.findById(id).map(course -> {
            course.setCompleted(true);
            courseRepository.save(course);
            return ResponseEntity.ok().build();
        }).orElseGet(() -> ResponseEntity.notFound().build());
    }
}